"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInstanceRegex = exports.extractInstanceFromActorId = exports.stripPort = exports.removeItem = exports.getListingType = exports.parseHandlers = exports.shouldProcess = exports.futureDaysToUnixTime = exports.correctVote = exports.getInsecureWebsocketUrl = exports.getSecureWebsocketUrl = void 0;
const types_1 = require("./types");
const getSecureWebsocketUrl = (instanceDomain) => `wss://${instanceDomain}/api/v3/ws`;
exports.getSecureWebsocketUrl = getSecureWebsocketUrl;
const getInsecureWebsocketUrl = (instanceDomain) => `ws://${instanceDomain}/api/v3/ws`;
exports.getInsecureWebsocketUrl = getInsecureWebsocketUrl;
const correctVote = (vote) => {
    if (vote < -1) {
        vote = types_1.Vote.Downvote;
    }
    if (vote > 1) {
        vote = types_1.Vote.Upvote;
    }
    return vote;
};
exports.correctVote = correctVote;
const futureDaysToUnixTime = (days) => days
    ? Math.trunc(new Date(Date.now() + 1000 * 60 * 60 * 24 * days).getTime() / 1000)
    : undefined;
exports.futureDaysToUnixTime = futureDaysToUnixTime;
const shouldProcess = ({ exists, reprocessTime }) => !exists || (reprocessTime && reprocessTime < new Date(Date.now()));
exports.shouldProcess = shouldProcess;
const parseHandlers = (handlers) => handlers
    ? Object.entries(handlers).reduce((acc, [key, val]) => (Object.assign(Object.assign({}, acc), { [key]: typeof val === 'function' ? { handle: val } : val })), {})
    : {};
exports.parseHandlers = parseHandlers;
const getListingType = (options) => {
    var _a, _b, _c;
    if (((_b = (_a = options.allowList) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 1) {
        return 'Local';
    }
    else if ((_c = options.allowList) === null || _c === void 0 ? void 0 : _c.every((i) => typeof i !== 'string')) {
        return 'Subscribed';
    }
    else {
        return 'All';
    }
};
exports.getListingType = getListingType;
function removeItem(items, itemPredicate) {
    for (let i = 0; i < items.length; ++i) {
        if (itemPredicate(items[i])) {
            items.splice(i, 1);
            break;
        }
    }
}
exports.removeItem = removeItem;
const stripPort = (instance) => instance.replace(/:.*/, '');
exports.stripPort = stripPort;
const escapeRegexString = (str) => (0, exports.stripPort)(str.replace(/\./g, '\\.'));
const formatActorId = (instance, community) => `https?://${instance}/c/(${community})`;
const extractInstanceFromActorId = (actorId) => actorId.match(/https?:\/\/(.*)\/(?:c|u)\/.*/)[1];
exports.extractInstanceFromActorId = extractInstanceFromActorId;
const getInstanceRegex = (instances) => {
    const stringInstances = [], objectInstances = [];
    for (const instance of instances) {
        if (typeof instance === 'string') {
            stringInstances.push(escapeRegexString(instance));
        }
        else {
            objectInstances.push(instance);
        }
    }
    const regexParts = [];
    if (stringInstances.length > 0) {
        regexParts.push(`^${formatActorId(stringInstances.join('|'), '.*')}$`);
    }
    if (objectInstances.length > 0) {
        regexParts.push(`(${objectInstances
            .map(({ instance, communities }) => `^${formatActorId(escapeRegexString(instance), communities.join('|'))}$`)
            .join('|')})`);
    }
    return new RegExp(regexParts.join('|'));
};
exports.getInstanceRegex = getInstanceRegex;
