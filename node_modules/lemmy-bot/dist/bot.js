"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _LemmyBot_instances, _LemmyBot_instance, _LemmyBot_username, _LemmyBot_password, _LemmyBot_connection, _LemmyBot_forcingClosed, _LemmyBot_timeouts, _LemmyBot_auth, _LemmyBot_isSecureConnection, _LemmyBot_defaultMinutesUntilReprocess, _LemmyBot_federationOptions, _LemmyBot_tasks, _LemmyBot_delayedTasks, _LemmyBot_unfinishedSearchMap, _LemmyBot_finishedSearchMap, _LemmyBot_httpClient, _LemmyBot_dbFile, _LemmyBot_postMap, _LemmyBot_commentMap, _LemmyBot_listingType, _LemmyBot_currentlyProcessingPostIds, _LemmyBot_currentlyProcessingCommentIds, _LemmyBot_botActions, _LemmyBot_login, _LemmyBot_subscribeToCommunities, _LemmyBot_handleEntry, _LemmyBot_filterInstancesFromResponse, _LemmyBot_getId, _LemmyBot_performLoggedInBotAction, _LemmyBot_retry;
Object.defineProperty(exports, "__esModule", { value: true });
const websocket_1 = require("websocket");
const uuid_1 = require("uuid");
const lemmy_js_client_1 = require("lemmy-js-client");
const helpers_1 = require("./helpers");
const actions_1 = require("./actions");
const db_1 = require("./db");
const reprocessHandler_1 = __importDefault(require("./reprocessHandler"));
const node_cron_1 = __importDefault(require("node-cron"));
const types_1 = require("./types");
const DEFAULT_SECONDS_BETWEEN_POLLS = 10;
const DEFAULT_MINUTES_BEFORE_RETRY_CONNECTION = 5;
const DEFAULT_MINUTES_UNTIL_REPROCESS = undefined;
const client = new websocket_1.client();
class LemmyBot {
    constructor({ instance, credentials, handlers, connection: { minutesBeforeRetryConnection = DEFAULT_MINUTES_BEFORE_RETRY_CONNECTION, minutesUntilReprocess: defaultMinutesUntilReprocess = DEFAULT_MINUTES_UNTIL_REPROCESS, secondsBetweenPolls: defaultSecondsBetweenPolls = DEFAULT_SECONDS_BETWEEN_POLLS } = {
        secondsBetweenPolls: DEFAULT_SECONDS_BETWEEN_POLLS,
        minutesBeforeRetryConnection: DEFAULT_MINUTES_BEFORE_RETRY_CONNECTION,
        minutesUntilReprocess: DEFAULT_MINUTES_UNTIL_REPROCESS
    }, dbFile, federation, schedule }) {
        var _a, _b, _c, _d, _e;
        _LemmyBot_instances.add(this);
        _LemmyBot_instance.set(this, void 0);
        _LemmyBot_username.set(this, void 0);
        _LemmyBot_password.set(this, void 0);
        _LemmyBot_connection.set(this, undefined);
        _LemmyBot_forcingClosed.set(this, false);
        _LemmyBot_timeouts.set(this, []);
        _LemmyBot_auth.set(this, void 0);
        _LemmyBot_isSecureConnection.set(this, true);
        _LemmyBot_defaultMinutesUntilReprocess.set(this, void 0);
        _LemmyBot_federationOptions.set(this, void 0);
        _LemmyBot_tasks.set(this, []);
        _LemmyBot_delayedTasks.set(this, []);
        _LemmyBot_unfinishedSearchMap.set(this, new Map());
        _LemmyBot_finishedSearchMap.set(this, new Map());
        _LemmyBot_httpClient.set(this, void 0);
        _LemmyBot_dbFile.set(this, void 0);
        _LemmyBot_postMap.set(this, new Map());
        _LemmyBot_commentMap.set(this, new Map());
        _LemmyBot_listingType.set(this, void 0);
        _LemmyBot_currentlyProcessingPostIds.set(this, []);
        _LemmyBot_currentlyProcessingCommentIds.set(this, []);
        _LemmyBot_botActions.set(this, {
            createPost: (form) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: 'Creating post',
                action: () => (0, actions_1.createPost)(__classPrivateFieldGet(this, _LemmyBot_connection, "f"), Object.assign(Object.assign({}, form), { auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f") })),
                description: 'create post'
            }),
            reportPost: ({ postId, reason }) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Reporting to post ID ${postId} for ${reason}`,
                action: () => (0, actions_1.createPostReport)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    id: postId,
                    reason
                }),
                description: 'report post'
            }),
            votePost: ({ postId, vote }) => {
                vote = (0, helpers_1.correctVote)(vote);
                const prefix = vote === types_1.Vote.Upvote ? 'Up' : vote === types_1.Vote.Downvote ? 'Down' : 'Un';
                __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                    logMessage: `${prefix}voting post ID ${postId}`,
                    action: () => (0, actions_1.voteDBPost)({
                        connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                        auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                        id: postId,
                        vote
                    }),
                    description: `${prefix.toLowerCase()}vote post`
                });
            },
            createComment: ({ parentId, content, postId, languageId }) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: parentId
                    ? `Replying to comment ID ${parentId}`
                    : `Replying to post ID ${postId}`,
                action: () => (0, actions_1.createComment)({
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    content,
                    postId,
                    parentId,
                    languageId
                }),
                description: 'post comment'
            }),
            reportComment: ({ commentId, reason }) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                action: () => (0, actions_1.createCommentReport)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    id: commentId,
                    reason
                }),
                logMessage: `Reporting to comment ID ${commentId} for ${reason}`,
                description: 'report comment'
            }),
            voteComment: ({ commentId, vote }) => {
                vote = (0, helpers_1.correctVote)(vote);
                const prefix = vote === types_1.Vote.Upvote ? 'Up' : vote === types_1.Vote.Downvote ? 'Down' : 'Un';
                __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                    logMessage: `${prefix}voting comment ID ${commentId}`,
                    action: () => (0, actions_1.voteDBComment)({
                        connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                        auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                        id: commentId,
                        vote
                    }),
                    description: `${prefix.toLowerCase()}vote comment`
                });
            },
            banFromCommunity: (form) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Banning user ID ${form.personId} from ${form.communityId}`,
                action: () => (0, actions_1.createBanFromCommunity)(Object.assign(Object.assign({}, form), { auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"), connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f") })),
                description: 'ban user'
            }),
            banFromSite: ({ personId, daysUntilExpires, reason, removeData }) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Banning user ID ${personId} from ${__classPrivateFieldGet(this, _LemmyBot_instance, "f")}`,
                action: () => (0, actions_1.createBanFromSite)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    personId,
                    daysUntilExpires,
                    reason,
                    removeData
                }),
                description: 'ban user'
            }),
            sendPrivateMessage: ({ recipientId, content }) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Sending private message to user ID ${recipientId}`,
                action: () => (0, actions_1.createPrivateMessage)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    content,
                    recipientId
                }),
                description: 'send message'
            }),
            reportPrivateMessage: ({ privateMessageId, reason }) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Reporting private message ID ${privateMessageId}. Reason: ${reason}`,
                action: () => (0, actions_1.createPrivateMessageReport)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    id: privateMessageId,
                    reason
                }),
                description: 'report message'
            }),
            approveRegistrationApplication: (applicationId) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Approving application ID ${applicationId}`,
                action: () => (0, actions_1.createApplicationApproval)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    approve: true,
                    id: applicationId
                }),
                description: 'approve application'
            }),
            rejectRegistrationApplication: ({ id, denyReason }) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Rejecting application ID ${id}`,
                action: () => (0, actions_1.createApplicationApproval)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    approve: false,
                    id,
                    denyReason
                }),
                description: 'reject application'
            }),
            removePost: ({ postId, reason }) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Removing post ID ${postId}`,
                action: () => (0, actions_1.createRemovePost)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    id: postId,
                    removed: true,
                    reason
                }),
                description: 'remove post'
            }),
            removeComment: ({ commentId, reason }) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Removing comment ID ${commentId}`,
                action: () => (0, actions_1.createRemoveComment)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    id: commentId,
                    removed: true,
                    reason
                }),
                description: 'remove comment'
            }),
            resolvePostReport: (postReportId) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Resolving post report ID ${postReportId}`,
                action: () => (0, actions_1.createResolvePostReport)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    id: postReportId
                }),
                description: 'resolve post report'
            }),
            resolveCommentReport: (commentReportId) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Resolving comment report ID ${commentReportId}`,
                action: () => (0, actions_1.createResolveCommentReport)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    id: commentReportId
                }),
                description: 'resolve comment report'
            }),
            resolvePrivateMessageReport: (privateMessageReportId) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `Resolving private message report ID ${privateMessageReportId}`,
                action: () => (0, actions_1.createResolvePrivateMessageReport)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    id: privateMessageReportId
                }),
                description: 'resolve message report'
            }),
            featurePost: ({ featureType, featured, postId }) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `${featured ? 'F' : 'Unf'}eaturing report ID ${postId}`,
                action: () => (0, actions_1.createFeaturePost)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    id: postId,
                    featured,
                    featureType
                }),
                description: 'feature post'
            }),
            lockPost: ({ postId, locked }) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_performLoggedInBotAction).call(this, {
                logMessage: `${locked ? 'L' : 'Unl'}ocking report ID ${postId}`,
                action: () => (0, actions_1.createLockPost)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                    id: postId,
                    locked
                }),
                description: `${locked ? '' : 'un'}lock post`
            }),
            getCommunityId: (form) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_getId).call(this, form, 'Communities', 'community'),
            getUserId: (form) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_getId).call(this, form, 'Users', 'user'),
            uploadImage: (image) => __classPrivateFieldGet(this, _LemmyBot_httpClient, "f").uploadImage({ image, auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f") }),
            getPost: (postId) => new Promise((resolve, reject) => {
                var _a;
                if ((_a = __classPrivateFieldGet(this, _LemmyBot_connection, "f")) === null || _a === void 0 ? void 0 : _a.connected) {
                    (0, actions_1.getPost)({
                        connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                        auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                        id: postId
                    });
                    let tries = 0;
                    const timeoutFunction = () => {
                        var _a, _b;
                        const postView = (_a = __classPrivateFieldGet(this, _LemmyBot_postMap, "f").get(postId)) === null || _a === void 0 ? void 0 : _a.pop();
                        if (postView !== undefined) {
                            if (((_b = __classPrivateFieldGet(this, _LemmyBot_postMap, "f").get(postId)) === null || _b === void 0 ? void 0 : _b.length) === 0) {
                                __classPrivateFieldGet(this, _LemmyBot_postMap, "f").delete(postId);
                            }
                            resolve(postView);
                        }
                        else if (tries < 20) {
                            ++tries;
                            setTimeout(timeoutFunction, 1000);
                        }
                        else {
                            reject(`Could not find post with ID ${postId}`);
                        }
                    };
                    setTimeout(timeoutFunction, 1000);
                }
                else {
                    reject(`Could not get post ${postId}: connection closed`);
                }
            }),
            getComment: (commentId) => new Promise((resolve, reject) => {
                var _a;
                if ((_a = __classPrivateFieldGet(this, _LemmyBot_connection, "f")) === null || _a === void 0 ? void 0 : _a.connected) {
                    (0, actions_1.getComment)({
                        connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                        auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                        id: commentId
                    });
                    let tries = 0;
                    const timeoutFunction = () => {
                        var _a, _b;
                        const commentView = (_a = __classPrivateFieldGet(this, _LemmyBot_commentMap, "f").get(commentId)) === null || _a === void 0 ? void 0 : _a.pop();
                        if (commentView !== undefined) {
                            if (((_b = __classPrivateFieldGet(this, _LemmyBot_commentMap, "f").get(commentId)) === null || _b === void 0 ? void 0 : _b.length) === 0) {
                                __classPrivateFieldGet(this, _LemmyBot_commentMap, "f").delete(commentId);
                            }
                            resolve(commentView);
                        }
                        else if (tries < 20) {
                            ++tries;
                            setTimeout(timeoutFunction, 1000);
                        }
                        else {
                            reject(`Could not find comment with ID ${commentId}`);
                        }
                    };
                    setTimeout(timeoutFunction, 1000);
                }
                else {
                    reject(`Could not get comment ${commentId}: connection closed`);
                }
            }),
            getParentOfComment: ({ path, post_id }) => __awaiter(this, void 0, void 0, function* () {
                const pathList = path.split('.').filter((i) => i !== '0');
                if (pathList.length === 1) {
                    return {
                        type: 'post',
                        data: yield __classPrivateFieldGet(this, _LemmyBot_botActions, "f").getPost(post_id)
                    };
                }
                else {
                    const parentId = Number(pathList[pathList.length - 2]);
                    return {
                        type: 'comment',
                        data: yield __classPrivateFieldGet(this, _LemmyBot_botActions, "f").getComment(parentId)
                    };
                }
            })
        });
        switch (federation) {
            case undefined:
            case 'local': {
                __classPrivateFieldSet(this, _LemmyBot_federationOptions, {
                    allowList: [instance]
                }, "f");
                break;
            }
            case 'all': {
                __classPrivateFieldSet(this, _LemmyBot_federationOptions, {
                    blockList: []
                }, "f");
                break;
            }
            default: {
                if (((_b = (_a = federation.allowList) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0 &&
                    ((_d = (_c = federation.blockList) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0) {
                    throw 'Cannot have both block list and allow list defined for federation options';
                }
                else if ((!federation.allowList || federation.allowList.length === 0) &&
                    (!federation.blockList || federation.blockList.length === 0)) {
                    throw 'Neither the block list nor allow list has any instances. To fix this issue, make sure either allow list or block list (not both) has at least one instance.\n\nAlternatively, the you can set the federation property to one of the strings "local" or "all".';
                }
                else if ((_e = federation.blockList) === null || _e === void 0 ? void 0 : _e.includes(instance)) {
                    throw 'Cannot put bot instance in blocklist unless blocking specific communities';
                }
                else {
                    __classPrivateFieldSet(this, _LemmyBot_federationOptions, federation, "f");
                    if (__classPrivateFieldGet(this, _LemmyBot_federationOptions, "f").allowList &&
                        !__classPrivateFieldGet(this, _LemmyBot_federationOptions, "f").allowList.some((i) => i === instance ||
                            i.instance === instance)) {
                        __classPrivateFieldGet(this, _LemmyBot_federationOptions, "f").allowList.push(instance);
                    }
                }
            }
        }
        if (schedule) {
            const tasks = Array.isArray(schedule) ? schedule : [schedule];
            for (const task of tasks) {
                if (!node_cron_1.default.validate(task.cronExpression)) {
                    throw `Schedule has invalid cron expression (${task.cronExpression}). Consult this documentation for valid expressions: https://www.gnu.org/software/mcron/manual/html_node/Crontab-file.html`;
                }
                __classPrivateFieldGet(this, _LemmyBot_tasks, "f").push(node_cron_1.default.schedule(task.cronExpression, () => __awaiter(this, void 0, void 0, function* () {
                    var _f;
                    if ((_f = __classPrivateFieldGet(this, _LemmyBot_connection, "f")) === null || _f === void 0 ? void 0 : _f.connected) {
                        yield task.doTask(__classPrivateFieldGet(this, _LemmyBot_botActions, "f"));
                    }
                    else {
                        __classPrivateFieldGet(this, _LemmyBot_delayedTasks, "f").push(() => __awaiter(this, void 0, void 0, function* () { return yield task.doTask(__classPrivateFieldGet(this, _LemmyBot_botActions, "f")); }));
                        client.connect((0, helpers_1.getSecureWebsocketUrl)(instance));
                    }
                }), task.timezone || task.runAtStart
                    ? Object.assign(Object.assign({}, (task.timezone ? { timezone: task.timezone } : {})), (task.runAtStart ? { runOnInit: task.runAtStart } : {})) : undefined));
            }
        }
        const { password, username } = credentials !== null && credentials !== void 0 ? credentials : {};
        __classPrivateFieldSet(this, _LemmyBot_instance, instance, "f");
        __classPrivateFieldSet(this, _LemmyBot_username, username, "f");
        __classPrivateFieldSet(this, _LemmyBot_password, password, "f");
        __classPrivateFieldSet(this, _LemmyBot_defaultMinutesUntilReprocess, defaultMinutesUntilReprocess, "f");
        __classPrivateFieldSet(this, _LemmyBot_httpClient, new lemmy_js_client_1.LemmyHttp(`https://${__classPrivateFieldGet(this, _LemmyBot_instance, "f")}`), "f");
        __classPrivateFieldSet(this, _LemmyBot_dbFile, dbFile, "f");
        __classPrivateFieldSet(this, _LemmyBot_listingType, (0, helpers_1.getListingType)(__classPrivateFieldGet(this, _LemmyBot_federationOptions, "f")), "f");
        const sanitizedMinutesBeforeRetryConnection = typeof minutesBeforeRetryConnection === 'number' &&
            minutesBeforeRetryConnection < 0
            ? 1
            : minutesBeforeRetryConnection;
        const { comment: commentOptions, post: postOptions, privateMessage: privateMessageOptions, registrationApplication: registrationApplicationOptions, mention: mentionOptions, reply: replyOptions, commentReport: commentReportOptions, postReport: postReportOptions, privateMessageReport: privateMessageReportOptions, modRemovePost: modRemovePostOptions, modLockPost: modLockPostOptions, modFeaturePost: modFeaturePostOptions, modRemoveComment: modRemoveCommentOptions, modRemoveCommunity: modRemoveCommunityOptions, modBanFromCommunity: modBanFromCommunityOptions, modAddModToCommunity: modAddModToCommunityOptions, modTransferCommunity: modTransferCommunityOptions, modAddAdmin: modAddAdminOptions, modBanFromSite: modBanFromSiteOptions } = (0, helpers_1.parseHandlers)(handlers);
        client.on('connectFailed', () => {
            if (!__classPrivateFieldGet(this, _LemmyBot_isSecureConnection, "f")) {
                console.log(`Connection Failed!${sanitizedMinutesBeforeRetryConnection
                    ? ` Bot will attempt to reconnect in ${sanitizedMinutesBeforeRetryConnection} minutes`
                    : ''}`);
                if (sanitizedMinutesBeforeRetryConnection) {
                    __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_retry).call(this, sanitizedMinutesBeforeRetryConnection);
                }
                __classPrivateFieldSet(this, _LemmyBot_isSecureConnection, true, "f");
            }
            else {
                __classPrivateFieldSet(this, _LemmyBot_isSecureConnection, false, "f");
                client.connect((0, helpers_1.getInsecureWebsocketUrl)(__classPrivateFieldGet(this, _LemmyBot_instance, "f")));
                __classPrivateFieldSet(this, _LemmyBot_httpClient, new lemmy_js_client_1.LemmyHttp(`http://${__classPrivateFieldGet(this, _LemmyBot_instance, "f")}`), "f");
            }
        });
        client.on('connect', (connection) => __awaiter(this, void 0, void 0, function* () {
            console.log('Connected to Lemmy Instance');
            __classPrivateFieldSet(this, _LemmyBot_connection, connection, "f");
            connection.on('error', (error) => {
                console.log('Connection error');
                console.log(`Error was: ${error.message}`);
            });
            connection.on('close', () => {
                const shouldReconnect = !__classPrivateFieldGet(this, _LemmyBot_forcingClosed, "f") && sanitizedMinutesBeforeRetryConnection;
                console.log(`Closing connection.${shouldReconnect
                    ? ` Bot will reconnect in ${sanitizedMinutesBeforeRetryConnection}`
                    : ''}`);
                if (shouldReconnect) {
                    __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_retry).call(this, sanitizedMinutesBeforeRetryConnection);
                }
            });
            connection.on('message', (message) => __awaiter(this, void 0, void 0, function* () {
                if (message.type === 'utf8') {
                    const response = JSON.parse(message.utf8Data);
                    if (response.error && response.error === 'not_logged_in') {
                        console.log('Not Logged in');
                        __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_login).call(this);
                    }
                    else if (response.error &&
                        (response.error === 'couldnt_find_that_username_or_email' ||
                            response.error === 'password_incorrect')) {
                        console.log('Could not log on');
                        connection.close();
                        process.exit(1);
                    }
                    else {
                        switch (response.op) {
                            case 'Login': {
                                console.log('Logging in');
                                __classPrivateFieldSet(this, _LemmyBot_auth, response.data.jwt, "f");
                                if (__classPrivateFieldGet(this, _LemmyBot_auth, "f")) {
                                    console.log('Marking account as bot account');
                                    (0, actions_1.enableBotAccount)({ connection, auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f") });
                                    console.log('Subscribing to communities');
                                    __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_subscribeToCommunities).call(this);
                                }
                                break;
                            }
                            case 'GetComments': {
                                const comments = __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_filterInstancesFromResponse).call(this, response.data.comments);
                                yield (0, db_1.useDatabaseFunctions)('comments', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                    yield Promise.all(comments
                                        .filter(({ comment: { id } }) => !__classPrivateFieldGet(this, _LemmyBot_currentlyProcessingCommentIds, "f").includes(id))
                                        .map((commentView) => __awaiter(this, void 0, void 0, function* () {
                                        __classPrivateFieldGet(this, _LemmyBot_currentlyProcessingCommentIds, "f").push(commentView.comment.id);
                                        if (commentOptions) {
                                            yield __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                                getStorageInfo: get,
                                                upsert,
                                                options: commentOptions,
                                                entry: { commentView },
                                                id: commentView.comment.id
                                            });
                                        }
                                        (0, helpers_1.removeItem)(__classPrivateFieldGet(this, _LemmyBot_currentlyProcessingCommentIds, "f"), (id) => id === commentView.comment.id);
                                    })));
                                }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                break;
                            }
                            case 'GetPosts': {
                                const posts = __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_filterInstancesFromResponse).call(this, response.data.posts);
                                if (postOptions) {
                                    yield (0, db_1.useDatabaseFunctions)('posts', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(posts
                                            .filter((p) => !__classPrivateFieldGet(this, _LemmyBot_currentlyProcessingPostIds, "f").includes(p.post.id))
                                            .map((postView) => __awaiter(this, void 0, void 0, function* () {
                                            __classPrivateFieldGet(this, _LemmyBot_currentlyProcessingPostIds, "f").push(postView.post.id);
                                            yield __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                                getStorageInfo: get,
                                                upsert,
                                                entry: { postView },
                                                id: postView.post.id,
                                                options: postOptions
                                            });
                                            (0, helpers_1.removeItem)(__classPrivateFieldGet(this, _LemmyBot_currentlyProcessingPostIds, "f"), (id) => id === postView.post.id);
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                break;
                            }
                            case 'GetPrivateMessages': {
                                const { private_messages } = response.data;
                                if (privateMessageOptions) {
                                    yield (0, db_1.useDatabaseFunctions)('messages', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(private_messages.map((messageView) => {
                                            const promise = __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                                getStorageInfo: get,
                                                options: privateMessageOptions,
                                                entry: { messageView },
                                                id: messageView.private_message.id,
                                                upsert
                                            });
                                            if (__classPrivateFieldGet(this, _LemmyBot_connection, "f") && __classPrivateFieldGet(this, _LemmyBot_auth, "f")) {
                                                (0, actions_1.markPrivateMessageAsRead)({
                                                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                                                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                                                    id: messageView.private_message.id
                                                });
                                                console.log(`Marked private message ID ${messageView.private_message.id} from ${messageView.creator.id} as read`);
                                                return promise;
                                            }
                                        }));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                break;
                            }
                            case 'GetPost': {
                                const { post_view } = response.data;
                                const posts = __classPrivateFieldGet(this, _LemmyBot_postMap, "f").get(post_view.post.id);
                                if (!posts) {
                                    __classPrivateFieldGet(this, _LemmyBot_postMap, "f").set(post_view.post.id, [post_view]);
                                }
                                else {
                                    posts.push(post_view);
                                }
                                break;
                            }
                            case 'GetComment': {
                                const { comment_view } = response.data;
                                const comments = __classPrivateFieldGet(this, _LemmyBot_commentMap, "f").get(comment_view.comment.id);
                                if (!comments) {
                                    __classPrivateFieldGet(this, _LemmyBot_commentMap, "f").set(comment_view.comment.id, [comment_view]);
                                }
                                else {
                                    comments.push(comment_view);
                                }
                                break;
                            }
                            case 'ListRegistrationApplications': {
                                const { registration_applications } = response.data;
                                if (registrationApplicationOptions) {
                                    yield (0, db_1.useDatabaseFunctions)('registrations', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(registration_applications.map((applicationView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            getStorageInfo: get,
                                            upsert,
                                            entry: { applicationView },
                                            id: applicationView.registration_application.id,
                                            options: registrationApplicationOptions
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                break;
                            }
                            case 'GetPersonMentions': {
                                const { mentions } = response.data;
                                if (mentionOptions) {
                                    yield (0, db_1.useDatabaseFunctions)('mentions', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(mentions.map((mentionView) => {
                                            const promise = __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                                entry: { mentionView },
                                                options: mentionOptions,
                                                getStorageInfo: get,
                                                id: mentionView.person_mention.id,
                                                upsert
                                            });
                                            if (__classPrivateFieldGet(this, _LemmyBot_connection, "f") && __classPrivateFieldGet(this, _LemmyBot_auth, "f")) {
                                                (0, actions_1.markMentionAsRead)({
                                                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                                                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                                                    id: mentionView.person_mention.id
                                                });
                                            }
                                            return promise;
                                        }));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                break;
                            }
                            case 'GetReplies': {
                                const { replies } = response.data;
                                if (replyOptions) {
                                    yield (0, db_1.useDatabaseFunctions)('replies', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(replies.map((replyView) => {
                                            const promise = __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                                entry: { replyView },
                                                options: replyOptions,
                                                getStorageInfo: get,
                                                id: replyView.comment_reply.id,
                                                upsert
                                            });
                                            if (__classPrivateFieldGet(this, _LemmyBot_connection, "f") && __classPrivateFieldGet(this, _LemmyBot_auth, "f")) {
                                                (0, actions_1.markReplyAsRead)({
                                                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                                                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                                                    id: replyView.comment_reply.id
                                                });
                                            }
                                            return promise;
                                        }));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                break;
                            }
                            case 'ListCommentReports': {
                                const { comment_reports } = response.data;
                                if (commentReportOptions) {
                                    yield (0, db_1.useDatabaseFunctions)('commentReports', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(comment_reports.map((reportView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { reportView },
                                            options: commentReportOptions,
                                            getStorageInfo: get,
                                            id: reportView.comment_report.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                break;
                            }
                            case 'ListPostReports': {
                                const { post_reports } = response.data;
                                if (postReportOptions) {
                                    yield (0, db_1.useDatabaseFunctions)('postReports', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(post_reports.map((reportView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { reportView },
                                            options: postReportOptions,
                                            getStorageInfo: get,
                                            id: reportView.post_report.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                break;
                            }
                            case 'ListPrivateMessageReports': {
                                const { private_message_reports } = response.data;
                                if (privateMessageReportOptions) {
                                    yield (0, db_1.useDatabaseFunctions)('messageReports', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(private_message_reports.map((reportView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { reportView },
                                            options: privateMessageReportOptions,
                                            getStorageInfo: get,
                                            id: reportView.private_message_report.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                break;
                            }
                            case 'GetModlog': {
                                const { removed_posts, locked_posts, featured_posts, removed_comments, removed_communities, banned_from_community, added_to_community, transferred_to_community, added, banned } = response.data;
                                if (modRemovePostOptions && removed_posts.length > 0) {
                                    yield (0, db_1.useDatabaseFunctions)('removedPosts', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(removed_posts.map((removedPostView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { removedPostView },
                                            options: modRemovePostOptions,
                                            getStorageInfo: get,
                                            id: removedPostView.mod_remove_post.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                if (modLockPostOptions && locked_posts.length > 0) {
                                    yield (0, db_1.useDatabaseFunctions)('lockedPosts', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(locked_posts.map((lockedPostView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { lockedPostView },
                                            options: modLockPostOptions,
                                            getStorageInfo: get,
                                            id: lockedPostView.mod_lock_post.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                if (modFeaturePostOptions && featured_posts.length > 0) {
                                    yield (0, db_1.useDatabaseFunctions)('featuredPosts', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(featured_posts.map((featuredPostView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { featuredPostView },
                                            options: modFeaturePostOptions,
                                            getStorageInfo: get,
                                            id: featuredPostView.mod_feature_post.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                if (modRemoveCommentOptions && removed_comments.length > 0) {
                                    yield (0, db_1.useDatabaseFunctions)('removedComments', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(removed_comments.map((removedCommentView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { removedCommentView },
                                            options: modRemoveCommentOptions,
                                            getStorageInfo: get,
                                            id: removedCommentView.mod_remove_comment.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                if (modRemoveCommunityOptions &&
                                    removed_communities.length > 0) {
                                    yield (0, db_1.useDatabaseFunctions)('removedCommunities', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(removed_communities.map((removedCommunityView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { removedCommunityView },
                                            options: modRemoveCommunityOptions,
                                            getStorageInfo: get,
                                            id: removedCommunityView.mod_remove_community.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                if (modBanFromCommunityOptions &&
                                    banned_from_community.length > 0) {
                                    yield (0, db_1.useDatabaseFunctions)('communityBans', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(banned_from_community.map((banView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { banView },
                                            options: modBanFromCommunityOptions,
                                            getStorageInfo: get,
                                            id: banView.mod_ban_from_community.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                if (modAddModToCommunityOptions &&
                                    added_to_community.length > 0) {
                                    yield (0, db_1.useDatabaseFunctions)('modsAddedToCommunities', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(added_to_community.map((modAddedToCommunityView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { modAddedToCommunityView },
                                            options: modAddModToCommunityOptions,
                                            getStorageInfo: get,
                                            id: modAddedToCommunityView.mod_add_community.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                if (modTransferCommunityOptions &&
                                    transferred_to_community.length > 0) {
                                    yield (0, db_1.useDatabaseFunctions)('modsTransferredToCommunities', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(transferred_to_community.map((modTransferredToCommunityView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { modTransferredToCommunityView },
                                            options: modTransferCommunityOptions,
                                            getStorageInfo: get,
                                            id: modTransferredToCommunityView
                                                .mod_transfer_community.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                if (modBanFromSiteOptions && banned.length > 0) {
                                    yield (0, db_1.useDatabaseFunctions)('siteBans', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(banned.map((banView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { banView },
                                            options: modBanFromSiteOptions,
                                            getStorageInfo: get,
                                            id: banView.mod_ban.id,
                                            upsert
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                if (modAddAdminOptions && added.length > 0) {
                                    yield (0, db_1.useDatabaseFunctions)('adminsAdded', ({ get, upsert }) => __awaiter(this, void 0, void 0, function* () {
                                        yield Promise.all(added.map((addedAdminView) => __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_handleEntry).call(this, {
                                            entry: { addedAdminView },
                                            options: modAddAdminOptions,
                                            getStorageInfo: get,
                                            upsert,
                                            id: addedAdminView.mod_add.id
                                        })));
                                    }), __classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                                }
                                break;
                            }
                            case 'Search': {
                                const { communities, users } = response.data;
                                for (const [key, { instance, name, type }] of __classPrivateFieldGet(this, _LemmyBot_unfinishedSearchMap, "f").entries()) {
                                    __classPrivateFieldGet(this, _LemmyBot_unfinishedSearchMap, "f").delete(key);
                                    let id = null;
                                    const instanceWithoutPort = (0, helpers_1.stripPort)(instance);
                                    if (type === 'Communities') {
                                        for (const { community } of communities) {
                                            if ((community.name === name || community.title === name) &&
                                                (0, helpers_1.extractInstanceFromActorId)(community.actor_id) ===
                                                    instanceWithoutPort) {
                                                id = community.id;
                                                break;
                                            }
                                        }
                                    }
                                    else {
                                        for (const { person } of users) {
                                            if ((person.name === name ||
                                                person.display_name === name) &&
                                                (0, helpers_1.extractInstanceFromActorId)(person.actor_id) ===
                                                    instanceWithoutPort) {
                                                id = person.id;
                                                break;
                                            }
                                        }
                                    }
                                    __classPrivateFieldGet(this, _LemmyBot_finishedSearchMap, "f").set(key, id);
                                }
                                break;
                            }
                            default: {
                                if (response.error &&
                                    response.error !== 'user_already_exists') {
                                    console.log(`Got error: ${response.error}`);
                                }
                                break;
                            }
                        }
                    }
                }
            }));
            const runChecker = (checker, secondsBetweenPolls = defaultSecondsBetweenPolls) => {
                var _a, _b;
                if (((_a = __classPrivateFieldGet(this, _LemmyBot_connection, "f")) === null || _a === void 0 ? void 0 : _a.connected) && (__classPrivateFieldGet(this, _LemmyBot_auth, "f") || !credentials)) {
                    checker(__classPrivateFieldGet(this, _LemmyBot_connection, "f"), __classPrivateFieldGet(this, _LemmyBot_auth, "f"));
                    const timeout = setTimeout(() => {
                        runChecker(checker, secondsBetweenPolls);
                        __classPrivateFieldSet(this, _LemmyBot_timeouts, __classPrivateFieldGet(this, _LemmyBot_timeouts, "f").filter((t) => t !== timeout), "f");
                    }, 1000 * secondsBetweenPolls);
                    __classPrivateFieldGet(this, _LemmyBot_timeouts, "f").push(timeout);
                }
                else if (((_b = __classPrivateFieldGet(this, _LemmyBot_connection, "f")) === null || _b === void 0 ? void 0 : _b.connected) && credentials && !__classPrivateFieldGet(this, _LemmyBot_auth, "f")) {
                    __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_login).call(this);
                    const timeout = setTimeout(() => {
                        runChecker(checker, secondsBetweenPolls);
                        __classPrivateFieldSet(this, _LemmyBot_timeouts, __classPrivateFieldGet(this, _LemmyBot_timeouts, "f").filter((t) => t !== timeout), "f");
                    }, 5000);
                    __classPrivateFieldGet(this, _LemmyBot_timeouts, "f").push(timeout);
                }
                else if (!__classPrivateFieldGet(this, _LemmyBot_forcingClosed, "f") &&
                    sanitizedMinutesBeforeRetryConnection) {
                    __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_retry).call(this, sanitizedMinutesBeforeRetryConnection);
                }
                else {
                    __classPrivateFieldSet(this, _LemmyBot_forcingClosed, false, "f");
                    while (__classPrivateFieldGet(this, _LemmyBot_timeouts, "f").length > 0) {
                        clearTimeout(__classPrivateFieldGet(this, _LemmyBot_timeouts, "f").pop());
                    }
                }
            };
            const runBot = () => __awaiter(this, void 0, void 0, function* () {
                yield (0, db_1.setupDB)(__classPrivateFieldGet(this, _LemmyBot_dbFile, "f"));
                if (credentials) {
                    __classPrivateFieldGet(this, _LemmyBot_instances, "m", _LemmyBot_login).call(this);
                }
                if (__classPrivateFieldGet(this, _LemmyBot_delayedTasks, "f").length > 0) {
                    yield Promise.all(__classPrivateFieldGet(this, _LemmyBot_delayedTasks, "f"));
                }
                for (const task of __classPrivateFieldGet(this, _LemmyBot_tasks, "f")) {
                    task.start();
                }
                if (postOptions) {
                    runChecker((conn, auth) => (0, actions_1.getPosts)({
                        connection: conn,
                        listingType: __classPrivateFieldGet(this, _LemmyBot_listingType, "f"),
                        auth,
                        sort: postOptions.sort
                    }), postOptions.secondsBetweenPolls);
                }
                if (commentOptions) {
                    runChecker((conn, auth) => (0, actions_1.getComments)({
                        connection: conn,
                        auth,
                        listingType: __classPrivateFieldGet(this, _LemmyBot_listingType, "f"),
                        sort: commentOptions.sort
                    }), commentOptions.secondsBetweenPolls);
                }
                if (privateMessageOptions && credentials) {
                    runChecker(actions_1.getPrivateMessages, privateMessageOptions.secondsBetweenPolls);
                }
                if (registrationApplicationOptions && credentials) {
                    runChecker(actions_1.getRegistrationApplications, registrationApplicationOptions.secondsBetweenPolls);
                }
                if (mentionOptions && credentials) {
                    runChecker(actions_1.getMentions, mentionOptions.secondsBetweenPolls);
                }
                if (replyOptions && credentials) {
                    runChecker(actions_1.getReplies, replyOptions.secondsBetweenPolls);
                }
                if (commentReportOptions && credentials) {
                    runChecker(actions_1.getCommentReports, commentReportOptions.secondsBetweenPolls);
                }
                if (postReportOptions && credentials) {
                    runChecker(actions_1.getPostReports, postReportOptions.secondsBetweenPolls);
                }
                if (privateMessageReportOptions && credentials) {
                    runChecker(actions_1.getPrivateMessageReports, privateMessageReportOptions.secondsBetweenPolls);
                }
                if (modRemovePostOptions) {
                    runChecker(actions_1.getRemovedPosts, modRemovePostOptions.secondsBetweenPolls);
                }
                if (modLockPostOptions) {
                    runChecker(actions_1.getLockedPosts, modLockPostOptions.secondsBetweenPolls);
                }
                if (modFeaturePostOptions) {
                    runChecker(actions_1.getFeaturedPosts, modFeaturePostOptions.secondsBetweenPolls);
                }
                if (modRemoveCommentOptions) {
                    runChecker(actions_1.getRemovedComments, modRemoveCommentOptions.secondsBetweenPolls);
                }
                if (modRemoveCommunityOptions) {
                    runChecker(actions_1.getRemovedCommunities, modRemoveCommunityOptions.secondsBetweenPolls);
                }
                if (modBanFromCommunityOptions) {
                    runChecker(actions_1.getBansFromCommunities, modBanFromCommunityOptions.secondsBetweenPolls);
                }
                if (modAddModToCommunityOptions) {
                    runChecker(actions_1.getModsAddedToCommunities, modAddModToCommunityOptions.secondsBetweenPolls);
                }
                if (modTransferCommunityOptions) {
                    runChecker(actions_1.getModsTransferringCommunities, modTransferCommunityOptions.secondsBetweenPolls);
                }
                if (modAddAdminOptions) {
                    runChecker(actions_1.getAddedAdmins, modAddAdminOptions.secondsBetweenPolls);
                }
                if (modBanFromSiteOptions) {
                    runChecker(actions_1.getBansFromSite, modBanFromSiteOptions.secondsBetweenPolls);
                }
            });
            yield runBot();
        }));
    }
    start() {
        if (!__classPrivateFieldGet(this, _LemmyBot_connection, "f")) {
            client.connect((0, helpers_1.getSecureWebsocketUrl)(__classPrivateFieldGet(this, _LemmyBot_instance, "f")));
        }
    }
    stop() {
        if (__classPrivateFieldGet(this, _LemmyBot_connection, "f")) {
            __classPrivateFieldSet(this, _LemmyBot_forcingClosed, true, "f");
            for (const task of __classPrivateFieldGet(this, _LemmyBot_tasks, "f")) {
                task.stop();
            }
            __classPrivateFieldGet(this, _LemmyBot_connection, "f").close();
        }
    }
}
_LemmyBot_instance = new WeakMap(), _LemmyBot_username = new WeakMap(), _LemmyBot_password = new WeakMap(), _LemmyBot_connection = new WeakMap(), _LemmyBot_forcingClosed = new WeakMap(), _LemmyBot_timeouts = new WeakMap(), _LemmyBot_auth = new WeakMap(), _LemmyBot_isSecureConnection = new WeakMap(), _LemmyBot_defaultMinutesUntilReprocess = new WeakMap(), _LemmyBot_federationOptions = new WeakMap(), _LemmyBot_tasks = new WeakMap(), _LemmyBot_delayedTasks = new WeakMap(), _LemmyBot_unfinishedSearchMap = new WeakMap(), _LemmyBot_finishedSearchMap = new WeakMap(), _LemmyBot_httpClient = new WeakMap(), _LemmyBot_dbFile = new WeakMap(), _LemmyBot_postMap = new WeakMap(), _LemmyBot_commentMap = new WeakMap(), _LemmyBot_listingType = new WeakMap(), _LemmyBot_currentlyProcessingPostIds = new WeakMap(), _LemmyBot_currentlyProcessingCommentIds = new WeakMap(), _LemmyBot_botActions = new WeakMap(), _LemmyBot_instances = new WeakSet(), _LemmyBot_login = function _LemmyBot_login() {
    if (__classPrivateFieldGet(this, _LemmyBot_connection, "f") && __classPrivateFieldGet(this, _LemmyBot_username, "f") && __classPrivateFieldGet(this, _LemmyBot_password, "f")) {
        (0, actions_1.logIn)({
            connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
            username: __classPrivateFieldGet(this, _LemmyBot_username, "f"),
            password: __classPrivateFieldGet(this, _LemmyBot_password, "f")
        });
    }
}, _LemmyBot_subscribeToCommunities = function _LemmyBot_subscribeToCommunities() {
    var _a, _b, _c, _d;
    return __awaiter(this, void 0, void 0, function* () {
        if (__classPrivateFieldGet(this, _LemmyBot_auth, "f") && ((_a = __classPrivateFieldGet(this, _LemmyBot_connection, "f")) === null || _a === void 0 ? void 0 : _a.connected)) {
            const communityIds = (yield Promise.all((_d = (_c = (_b = __classPrivateFieldGet(this, _LemmyBot_federationOptions, "f").allowList) === null || _b === void 0 ? void 0 : _b.filter((i) => typeof i !== 'string')) === null || _c === void 0 ? void 0 : _c.flatMap(({ communities, instance }) => communities.map((name) => __classPrivateFieldGet(this, _LemmyBot_botActions, "f").getCommunityId({ instance, name })))) !== null && _d !== void 0 ? _d : [])).filter((id) => id !== undefined);
            for (const communityId of communityIds) {
                (0, actions_1.followCommunity)({
                    auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                    communityId,
                    connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f")
                });
            }
        }
    });
}, _LemmyBot_handleEntry = function _LemmyBot_handleEntry({ getStorageInfo, upsert, options, id, entry }) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const storageInfo = yield getStorageInfo(id);
        if ((0, helpers_1.shouldProcess)(storageInfo)) {
            const { get, preventReprocess, reprocess } = new reprocessHandler_1.default((_a = options === null || options === void 0 ? void 0 : options.minutesUntilReprocess) !== null && _a !== void 0 ? _a : __classPrivateFieldGet(this, _LemmyBot_defaultMinutesUntilReprocess, "f"));
            yield options.handle(Object.assign({ botActions: __classPrivateFieldGet(this, _LemmyBot_botActions, "f"), preventReprocess,
                reprocess }, entry));
            yield upsert(id, get());
        }
    });
}, _LemmyBot_filterInstancesFromResponse = function _LemmyBot_filterInstancesFromResponse(response) {
    var _a, _b, _c, _d, _e;
    let data = response;
    if (((_b = (_a = __classPrivateFieldGet(this, _LemmyBot_federationOptions, "f").allowList) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0 &&
        !((_c = __classPrivateFieldGet(this, _LemmyBot_federationOptions, "f").allowList) === null || _c === void 0 ? void 0 : _c.includes(__classPrivateFieldGet(this, _LemmyBot_instance, "f")))) {
        const instanceRegex = (0, helpers_1.getInstanceRegex)(__classPrivateFieldGet(this, _LemmyBot_federationOptions, "f").allowList);
        data = data.filter((d) => instanceRegex.test(d.community.actor_id));
    }
    if (((_e = (_d = __classPrivateFieldGet(this, _LemmyBot_federationOptions, "f").blockList) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0) {
        const instanceRegex = (0, helpers_1.getInstanceRegex)(__classPrivateFieldGet(this, _LemmyBot_federationOptions, "f").blockList);
        data = data.filter((d) => !instanceRegex.test(d.community.actor_id));
    }
    return data;
}, _LemmyBot_getId = function _LemmyBot_getId(form, type, label) {
    return new Promise((resolve, reject) => {
        var _a;
        if ((_a = __classPrivateFieldGet(this, _LemmyBot_connection, "f")) === null || _a === void 0 ? void 0 : _a.connected) {
            const key = (0, uuid_1.v4)();
            let localOptions;
            if (typeof form === 'string') {
                localOptions = {
                    name: form,
                    instance: __classPrivateFieldGet(this, _LemmyBot_instance, "f")
                };
            }
            else {
                localOptions = form;
            }
            __classPrivateFieldGet(this, _LemmyBot_unfinishedSearchMap, "f").set(key, Object.assign(Object.assign({}, localOptions), { type }));
            (0, actions_1.createSearch)({
                connection: __classPrivateFieldGet(this, _LemmyBot_connection, "f"),
                auth: __classPrivateFieldGet(this, _LemmyBot_auth, "f"),
                query: localOptions.name,
                type
            });
            let tries = 0;
            const timeoutFunction = () => {
                const result = __classPrivateFieldGet(this, _LemmyBot_finishedSearchMap, "f").get(key);
                if (result !== undefined) {
                    __classPrivateFieldGet(this, _LemmyBot_finishedSearchMap, "f").delete(key);
                    resolve(result !== null && result !== void 0 ? result : undefined);
                }
                else if (tries < 20) {
                    ++tries;
                    setTimeout(timeoutFunction, 1000);
                }
                else {
                    __classPrivateFieldGet(this, _LemmyBot_unfinishedSearchMap, "f").delete(key);
                    reject(`Could not find ${label} ID`);
                }
            };
            setTimeout(timeoutFunction, 1000);
        }
        else {
            reject(`Could not get ${label} ID: connection closed`);
        }
    });
}, _LemmyBot_performLoggedInBotAction = function _LemmyBot_performLoggedInBotAction({ logMessage, action, description }) {
    if (__classPrivateFieldGet(this, _LemmyBot_connection, "f") && __classPrivateFieldGet(this, _LemmyBot_auth, "f")) {
        console.log(logMessage);
        action();
    }
    else {
        console.log(`Must be ${!__classPrivateFieldGet(this, _LemmyBot_connection, "f") ? 'connected' : 'logged in'} to ${description}`);
    }
}, _LemmyBot_retry = function _LemmyBot_retry(minutesBeforeRetry) {
    const timeout = setTimeout(() => {
        client.connect((0, helpers_1.getSecureWebsocketUrl)(__classPrivateFieldGet(this, _LemmyBot_instance, "f")));
        __classPrivateFieldSet(this, _LemmyBot_timeouts, __classPrivateFieldGet(this, _LemmyBot_timeouts, "f").filter((t) => t !== timeout), "f");
        clearTimeout(timeout);
        // If bot can't connect, try again in the number of minutes provided
    }, 1000 * 60 * minutesBeforeRetry);
    __classPrivateFieldGet(this, _LemmyBot_timeouts, "f").push(timeout);
};
exports.default = LemmyBot;
