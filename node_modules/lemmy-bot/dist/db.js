"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupDB = exports.useDatabaseFunctions = void 0;
const sqlite3_1 = require("sqlite3");
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = __importDefault(require("path"));
const sqlite = (0, sqlite3_1.verbose)();
const tableTypes = [
    'comments',
    'posts',
    'messages',
    'registrations',
    'mentions',
    'replies',
    'comments',
    'commentReports',
    'postReports',
    'messageReports',
    'removedPosts',
    'lockedPosts',
    'featuredPosts',
    'removedComments',
    'removedCommunities',
    'communityBans',
    'modsAddedToCommunities',
    'modsTransferredToCommunities',
    'adminsAdded',
    'siteBans'
];
const getRow = (db, id, table) => new Promise((resolve, reject) => {
    db.get(`SELECT id, reprocessTime FROM ${table} WHERE id=?;`, id, (err, row) => {
        if (err) {
            reject(err);
        }
        else {
            resolve({
                exists: !!row,
                reprocessTime: row && row.reprocessTime ? new Date(row.reprocessTime) : null
            });
        }
    });
});
const upsert = (db, id, table, minutesUntilReprocess) => new Promise((resolve, reject) => {
    db.run(`INSERT INTO ${table} (id, reprocessTime) VALUES ($id, $reprocessTime) ON CONFLICT (id) DO UPDATE SET reprocessTime=$reprocessTime;`, {
        $id: id,
        $reprocessTime: minutesUntilReprocess && minutesUntilReprocess > 0
            ? Date.now() + 1000 * 60 * minutesUntilReprocess
            : null
    }, (err) => {
        if (err) {
            reject(err);
        }
        else {
            resolve();
        }
    });
});
const tableFuncMap = new Map(tableTypes.map((tt) => [
    tt,
    {
        get: (db, id) => __awaiter(void 0, void 0, void 0, function* () { return yield getRow(db, id, tt); }),
        upsert: (db, id, minutesUntilReprocess) => __awaiter(void 0, void 0, void 0, function* () { return yield upsert(db, id, tt, minutesUntilReprocess); })
    }
]));
let memoryDb = undefined;
const useDatabase = (doStuffWithDB, dbPath) => __awaiter(void 0, void 0, void 0, function* () {
    let db;
    if (!dbPath) {
        if (memoryDb) {
            db = memoryDb;
        }
        else {
            memoryDb = new sqlite3_1.Database(':memory:');
            db = memoryDb;
        }
    }
    else {
        db = new sqlite.Database(dbPath);
    }
    yield doStuffWithDB(db);
    if (dbPath) {
        db.close();
    }
});
const useDatabaseFunctions = (table, doStuff, dbPath) => __awaiter(void 0, void 0, void 0, function* () {
    yield useDatabase((db) => __awaiter(void 0, void 0, void 0, function* () {
        const { get, upsert } = tableFuncMap.get(table);
        yield doStuff({
            get: (id) => get(db, id),
            upsert: (id, minutesUntilReprocess) => upsert(db, id, minutesUntilReprocess)
        });
    }), dbPath);
});
exports.useDatabaseFunctions = useDatabaseFunctions;
const createTable = (db, table) => {
    db.run(`CREATE TABLE IF NOT EXISTS ${table} (id INTEGER PRIMARY KEY, reprocessTime INTEGER) WITHOUT ROWID;`);
    db.run(`CREATE UNIQUE INDEX IF NOT EXISTS idx_${table}_id ON ${table} (id);`);
};
const setupDB = (dbPath) => __awaiter(void 0, void 0, void 0, function* () {
    if (dbPath && !(0, fs_1.existsSync)(dbPath)) {
        console.log('Creating database file');
        try {
            yield (0, promises_1.mkdir)(path_1.default.dirname(dbPath), { recursive: true });
            yield (0, promises_1.writeFile)(dbPath, '');
        }
        catch (error) {
            console.log('Error making database file: ' + error);
            process.exit(1);
        }
    }
    yield useDatabase((db) => __awaiter(void 0, void 0, void 0, function* () {
        db.serialize(() => {
            console.log('Initializing DB');
            for (const table of tableTypes) {
                createTable(db, table);
            }
        });
    }), dbPath);
});
exports.setupDB = setupDB;
